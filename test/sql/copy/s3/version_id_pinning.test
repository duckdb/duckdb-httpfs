# name: test/sql/copy/s3/version_id_pinning.test
# description: Test S3 version ID pinning: reads remain pinned to the original object version even after the file is overwritten.
# group: [s3]

require parquet

require httpfs

require-env S3_TEST_SERVER_AVAILABLE 1

require-env AWS_DEFAULT_REGION

require-env AWS_ACCESS_KEY_ID

require-env AWS_SECRET_ACCESS_KEY

require-env DUCKDB_S3_ENDPOINT

require-env DUCKDB_S3_USE_SSL

# override the default behaviour of skipping HTTP errors and connection failures: this test fails on connection issues
set ignore_error_messages

# disable external file cache to avoid interference from locally cached file content
statement ok
SET enable_external_file_cache=false;

# Create two tables with different content, so we can distinguish them
statement ok
CREATE TABLE T1 AS SELECT i FROM range(100) tbl(i);

statement ok
CREATE TABLE T2 AS SELECT i*i FROM range(200) tbl(i);

# Write T1 to S3 (bucket must have versioning enabled)
statement ok
COPY T1 TO 's3://test-bucket/root-dir/version_pinning/test.parquet';

# Enable version pinning and the global metadata cache.
# The global metadata cache persists version_id across queries.
statement ok
SET s3_version_id_pinning=true;

statement ok
SET enable_http_metadata_cache=true;

statement ok
CALL enable_logging('HTTP');

# Read the file. This performs a HEAD request that captures version_id V1
# and stores it in the global metadata cache.
query I
SELECT COUNT(*) FROM 's3://test-bucket/root-dir/version_pinning/test.parquet';
----
100

query I
SELECT request.type FROM duckdb_logs_parsed('HTTP') WHERE response.headers['x-amz-version-id'] IS NOT NULL
----
HEAD
GET

# Disable the global metadata cache BEFORE overwriting.
# This way the COPY TO below erases from the per-context cache only,
# leaving the global cache entry (with V1's version_id) intact.
statement ok
SET enable_http_metadata_cache=false;

# Overwrite the file with T2 (200 rows), creating a new version V2.
# Because the global metadata cache is disabled, the write erases from
# the per-context cache, not the global cache.
statement ok
COPY T2 TO 's3://test-bucket/root-dir/version_pinning/test.parquet';

# Re-enable the global metadata cache. It still holds the V1 entry.
statement ok
SET enable_http_metadata_cache=true;

# Read the file again. The global cache provides the V1 version_id,
# so the GET request includes ?versionId=V1 and returns the original T1 data.
query I
SELECT * FROM 's3://test-bucket/root-dir/version_pinning/test.parquet' LIMIT 5;
----
0
1
2
3
4

# --- Clearing the version pin ---
# To read the latest version, we need to clear the cached version_id.
# Disabling the global metadata cache and version pinning achieves this:
# the per-context cache starts empty each query, and no version_id is captured.
statement ok
SET enable_http_metadata_cache=false;

statement ok
SET s3_version_id_pinning=false;

# Read the file again. The global cache provides the V1 version_id,
# so the GET request includes ?versionId=V1 and returns the original T1 data.
query I
SELECT * FROM 's3://test-bucket/root-dir/version_pinning/test.parquet' LIMIT 5;
----
0
1
4
9
16

query II
SELECT request.type FROM (FROM duckdb_logs_parsed('HTTP') WHERE response.headers['x-amz-version-id'] IS NOT NULL);
----
HEAD
GET
PUT
GET
GET
HEAD
GET
GET
